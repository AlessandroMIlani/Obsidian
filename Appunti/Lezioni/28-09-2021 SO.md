## Struttura architetturale di un SO
- Originariamente scritti per una pecifica arhcitettura
	- sfruttando il suo linguaggio assembly 
- Adesso si usa un linguaggio iù ad alto livello (come il C)
	- permette una portabilità del SO

### UNISCS 
Struttura stratificata (gli strati centrali rappresentano il SO)
- Utenti
	-  Comandi, compilatori, editor
	- Interfaccia: system call
	- **Kernel, cuore del sistema operativo (gestisce processi, file system, segnali ...)**
	- interfaccia tra kernel e HW (Driver)
	- Controller dei dispositivi (sempre hardware)
- Hardware
```mermaid 
	flowchart BT
 A[Hardware]--> B[interfaccia tra kernel e HW] --> C[Kernel, cuore del sistema operativo] --> D[Interfaccia: system call] --> E[Comandi, compilatori, editor] --> Utenti
```
Sviluppando il kernel dopo dopo i driver e l'HW posso permettermi di renderlo indipendente da essi
- non mi interessa come sono implementati i driver, basta sapere come invocarli (magari tramite un metodo standardizzato)

	- Ragionamento simile per le sys.call


Quindi: ogni **livello nasconde i sottostanti**, rendendoli indipendendti nello sviluppo

## Contro
- il ragionamento a stranti non è banale
- più strati ci sono, più è lenta l'esecuzione (ogni comando deve scendeer e risalire i vari strati)

La truttura stratificata, era stata abbandonata per un periodo, ma è tornata in auge con le macchine virtuali e i sistemi cloud

```mermaid 
	flowchart BT
 HW --> So.Residente --> C[Hypervisor \n cpu e memorie virtuali] --> A[SO1 - Ubuntu]  & B[SO2 - Windows]
```

Durante il periodo di "assenza" della stratificazione, si è utilizzato il sistema "micro-kernel"
- il kernel deve gestire meno cose possibile
	- processi
	- memoria
	- comunicazione (scambi di messaggi)

- Tutte il resto sono pogrammi applicativi  -> moduli 
```mermaid 
	flowchart RL
 M1 -->A[Micro Kernel];
 M2 --> A
 M3 --> A
```

La comunicazione è quello che ha reso il tutto più ostico.
- se m1, deve comunicare con m3:
	- m1 manda il messaggio al kernel
	- il kernel lo rigira ad m3
	- m3 riceve il messaggio
	- m3 manda la risposta al kernel
	- il kernel la rigira ad m1 

Adesso si tenta di mantenere un kernel snello con l'aggiunta di moduli (anche a sistema avviato)

bisogna definire dei criteri ---> implementare tramite meccanismi 
   - (criterio -> aule da riempire al 50% | meccanismo -> sistema di prenotazione con max 50% dei posti)